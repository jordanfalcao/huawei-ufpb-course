# -*- coding: utf-8 -*-
"""estudo_de_caso_1D.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yMkMStZ73-YsAB_jllcx_aNTlPcFCCBN

# Estudo de Caso: Regressão Linear
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""## Para uma variável (1D)

### Etapa 1: Entrada de Dados
"""

filename = 'ex1data1.txt'
df = pd.read_csv(filename,header=None,names=['População','Lucro'])

df.head()

df.tail()

varX = 'População'
varY = 'Lucro'

X = df[varX].values
y = df[varY].values
m = y.size

"""### Etapa 2: Visualização Inicial"""

fig = plt.figure(figsize=(8,5))
plt.title('Dados Originais', fontsize = 16)
plt.grid()
plt.xlabel(varX, fontsize = 14)
plt.ylabel(varY, fontsize = 14)
plt.scatter(X, y)
plt.show()

"""### Etapa 3: Ajuste Manual"""

# Construção de X

Xn = np.ones((m,2))
Xn[:,1] = X
X = Xn
print(X[:5,:])

# X      *    w       =   yest
# m x 2       2 x 1       m x 1

# Construção de y

yn = np.zeros((m,1))
yn[:,0] = y
y = yn
print(y[:5])

# y
# m x 1

# Construção de w

w = np.array([[y.mean(),0]]).T
w = np.array([[-1.0,1.0]]).T
print(w)

yest = X.dot(w) # yest = X * w

print(y[:5])

fig = plt.figure(figsize=(10,6))
plt.title(f'Dados Originais e Reta')
plt.grid()
plt.xlabel(varX)
plt.ylabel(varY)
plt.scatter(X[:,1], y)
plt.plot(X[:,1], yest, color='red')
plt.show()

"""### Etapa 4: Função de Perdas"""

w = np.array([[-1.0,1.0]]).T

yest = X.dot(w)
erro = yest - y
fp = (erro**2).mean()/2

fig = plt.figure(figsize=(10,6))
plt.title(f'Dados Originais e Reta (MSE = {fp})')
plt.grid()
plt.xlabel(varX)
plt.ylabel(varY)
plt.scatter(X[:,1], y)
plt.plot(X[:,1], yest, color='red')
plt.show()

"""### Etapa 5: Gradient Descent"""

def calcula_Jw(X, y, w):
  yest = X.dot(w)
  erro = yest - y
  return (erro**2).mean()/2

def calcula_iteracoes_GD(X, y, w, alpha, iters):
  m = y.size
  mem_Jw = np.zeros((iters,1))
  
  for iter in range(iters):
    yest = X.dot(w)
    w = w - (alpha/m) * (X.T).dot(yest - y)
    mem_Jw[iter] = calcula_Jw(X, y, w)
    
  return w, mem_Jw

# Teste

w = np.array([[y.mean(),0]]).T
alpha = 0.02
iters = 2000
w,mem_Jw = calcula_iteracoes_GD(X, y, w, alpha, iters)
print(f'w = \n{w}')

# Evolução

fig = plt.figure(figsize=(10,6))
plt.title(f'Evolução da função Jw')
plt.grid()
plt.xlabel('Iterações')
plt.ylabel('J(w)')
plt.plot(range(iters), mem_Jw)
plt.show()

# Resposta obtida
# 1000 => 0.01
#  600 => 0.02

yest = X.dot(w)

fig = plt.figure(figsize=(10,6))
plt.title(f'Dados Originais e Reta (MSE = {mem_Jw[-1]})')
plt.grid()
plt.xlabel(varX)
plt.ylabel(varY)
plt.scatter(X[:,1], y)
plt.plot(X[:,1], yest, color='red')
plt.show()

